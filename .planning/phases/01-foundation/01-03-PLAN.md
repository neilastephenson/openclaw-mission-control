---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - convex/openclawWebhook.ts
  - convex/schema.ts
  - convex/activity.ts
autonomous: true

must_haves:
  truths:
    - "Webhook endpoint receives POST /openclaw/event and stores parsed event data in Convex"
    - "Webhook parses agent ID, task context, and usage data from incoming payloads"
    - "Dashboard updates in real-time when a webhook event arrives (no page refresh needed)"
    - "Activity feed shows new events within seconds of webhook delivery"
  artifacts:
    - path: "convex/openclawWebhook.ts"
      provides: "HTTP endpoint handler for OpenClaw webhook events"
      contains: "httpAction"
    - path: "convex/schema.ts"
      provides: "Extended schema with usage fields on activity/events table"
      contains: "defineSchema"
    - path: "convex/activity.ts"
      provides: "Mutations and queries for activity events"
      exports: ["recordEvent", "listActivity"]
  key_links:
    - from: "convex/openclawWebhook.ts"
      to: "convex/activity.ts"
      via: "Webhook handler calls recordEvent mutation to store parsed data"
      pattern: "ctx.runMutation.*recordEvent"
    - from: "convex/activity.ts"
      to: "convex/schema.ts"
      via: "Activity mutations write to schema-defined tables"
      pattern: "ctx.db.insert"
    - from: "src/components/"
      to: "convex/activity.ts"
      via: "React components subscribe to activity queries via useQuery"
      pattern: "useQuery.*listActivity"
---

<objective>
Extend the OpenClaw webhook integration to parse project IDs, usage/token data from webhook payloads, and ensure the real-time subscription pipeline works end-to-end (webhook POST -> Convex mutation -> reactive query -> UI update).

Purpose: Requirements INTG-01, INTG-02, INTG-03 — the webhook is the only data source for agent activity. If this doesn't work, the dashboard has nothing to show.
Output: Enhanced webhook handler that parses richer data, activity queries that power the dashboard, and verified real-time updates.
</objective>

<execution_context>
@/Users/otto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/otto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend webhook handler and schema for richer event data</name>
  <files>
    convex/openclawWebhook.ts
    convex/schema.ts
    convex/activity.ts
    convex/http.ts
  </files>
  <action>
    First, study the stock webhook implementation thoroughly. Read:
    - convex/http.ts (or wherever HTTP routes are defined)
    - The existing webhook handler file
    - convex/schema.ts for current table definitions
    - hooks/mission-control/ for the hook handler that sends events

    Then extend:

    **1. Schema updates** (convex/schema.ts):
    Add or extend the activity/events table to include these fields (add to existing, do not break existing fields):
    - `agentId` (string) — extracted from sessionKey or matched from agent name
    - `projectId` (optional string) — extracted from payload if present (agents will tag project in future)
    - `taskId` (optional string) — linked task reference
    - `eventType` (string) — "start" | "progress" | "end" | "error"
    - `source` (string) — "Telegram" | "Discord" | etc.
    - `prompt` (optional string) — the user prompt that triggered this run
    - `response` (optional string) — the agent's response
    - `error` (optional string) — error message if eventType is "error"
    - `usage` (optional object) — { inputTokens?: number, outputTokens?: number, totalTokens?: number, model?: string, cost?: number }
    - `runId` (string) — unique run identifier for grouping related events
    - `timestamp` (number) — event timestamp

    If the stock schema already has some of these, keep existing fields and add missing ones.

    **2. Webhook handler** (convex/openclawWebhook.ts or existing file):
    Extend the POST handler to:
    - Parse the incoming JSON body with the full payload shape:
      ```typescript
      {
        runId: string;
        action: "start" | "end" | "error" | "progress";
        sessionKey: string;
        prompt?: string;
        response?: string;
        source?: string;
        error?: string;
        usage?: { inputTokens?: number; outputTokens?: number; totalTokens?: number; model?: string; };
      }
      ```
    - Extract agentId from sessionKey (the sessionKey typically contains the agent name/identifier)
    - Look up or create the agent in the agents table if not found
    - Store the full event with all parsed fields via a mutation
    - Return 200 OK on success, 400 on malformed payload, 500 on internal error
    - Log incoming events for debugging (console.log with event type and runId)

    **3. Activity mutations/queries** (convex/activity.ts):
    - `recordEvent` mutation: accepts parsed webhook data, inserts into activity table with timestamp
    - `listActivity` query: returns recent activity events, ordered by timestamp desc, limited to 100
    - `listActivityByAgent` query: same but filtered by agentId
    - Both queries should be reactive (standard Convex queries are reactive by default)

    **4. HTTP route registration** (convex/http.ts):
    - Ensure the webhook endpoint is registered at `/openclaw/event` (POST)
    - If stock repo already registers this, verify the path and update handler reference if needed

    IMPORTANT: Do NOT break existing stock webhook behavior. Extend it. If the stock handler creates tasks from webhook events, preserve that behavior.
  </action>
  <verify>
    - `npx convex dev --once` deploys schema without errors
    - `npx tsc --noEmit` passes
    - Test webhook with curl:
      ```bash
      curl -X POST http://127.0.0.1:3210/openclaw/event \
        -H "Content-Type: application/json" \
        -d '{"runId":"test-001","action":"start","sessionKey":"otto-main","prompt":"Hello world","source":"Telegram"}'
      ```
      Returns 200 OK
    - Check Convex dashboard: activity table has the new event
    - Send a second event (progress):
      ```bash
      curl -X POST http://127.0.0.1:3210/openclaw/event \
        -H "Content-Type: application/json" \
        -d '{"runId":"test-001","action":"end","sessionKey":"otto-main","response":"Done!","source":"Telegram","usage":{"inputTokens":100,"outputTokens":50,"totalTokens":150,"model":"claude-sonnet-4-20250514"}}'
      ```
      Returns 200 OK and event appears in activity table with usage data
  </verify>
  <done>
    Webhook handler parses all fields from OpenClaw events including usage data. Events stored in Convex with agentId, projectId, usage, and all metadata. Activity queries return events in real-time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end real-time pipeline</name>
  <files>
    convex/activity.ts
  </files>
  <action>
    Verify the full real-time pipeline works: webhook POST -> Convex mutation -> reactive query -> UI update.

    1. Start the dev server (`bun dev`) and open the dashboard in a browser

    2. Open browser dev tools console and verify the Convex connection is active (no errors)

    3. Send a test webhook event via curl (from another terminal):
       ```bash
       curl -X POST http://127.0.0.1:3210/openclaw/event \
         -H "Content-Type: application/json" \
         -d '{"runId":"live-test-001","action":"start","sessionKey":"otto-main","prompt":"Testing real-time updates","source":"Telegram"}'
       ```

    4. Verify the event appears in the dashboard WITHOUT refreshing the page:
       - If Activity tab exists and shows events, the new event should appear at the top
       - If the stock task board creates tasks from webhooks, a new task should appear
       - Sidebar agent status should update (agent becomes "active")

    5. Send an end event:
       ```bash
       curl -X POST http://127.0.0.1:3210/openclaw/event \
         -H "Content-Type: application/json" \
         -d '{"runId":"live-test-001","action":"end","sessionKey":"otto-main","response":"Test complete","source":"Telegram","usage":{"inputTokens":500,"outputTokens":200,"totalTokens":700,"model":"claude-sonnet-4-20250514","cost":0.0034}}'
       ```

    6. Verify:
       - Event appears in real-time in dashboard
       - Agent status updates (if the agent was just created, it should show in sidebar)
       - No console errors

    7. If any part of the pipeline is broken, fix it:
       - Webhook not receiving? Check HTTP route registration in convex/http.ts
       - Event not stored? Check mutation in activity.ts
       - UI not updating? Check that components use useQuery for activity data
       - Agent not showing? Check agent lookup/creation in webhook handler

    Clean up test data from Convex dashboard if needed, or leave it as demo data.
  </action>
  <verify>
    - Send webhook POST -> event appears in UI within 2 seconds (no page refresh)
    - Multiple sequential events (start, progress, end) all appear in order
    - Agent list in sidebar reflects agents from webhook events
    - No JavaScript console errors during the flow
    - Usage data from end event is stored and queryable
  </verify>
  <done>
    End-to-end real-time pipeline verified: webhook events flow from HTTP POST through Convex mutations to reactive UI updates within seconds. Usage data is parsed and stored. Agent status indicators update based on event activity.
  </done>
</task>

</tasks>

<verification>
1. POST /openclaw/event accepts and parses webhook payloads correctly
2. Events with start/progress/end/error actions are all handled
3. Agent ID is extracted from sessionKey
4. Usage data (tokens, model, cost) is stored when present
5. Dashboard updates in real-time when webhook events arrive
6. Activity feed shows events with timestamps, agent names, and action types
7. No page refresh needed to see new events
</verification>

<success_criteria>
- INTG-01: Webhook endpoint receives and processes start/progress/end/error events
- INTG-02: Agent ID, task context, and usage data parsed from webhook payloads
- INTG-03: Dashboard updates reactively via Convex subscriptions when events arrive
- End-to-end latency under 2 seconds (webhook to UI update)
- Error events are captured with error messages
- Usage/token data stored for future cost tracking
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
